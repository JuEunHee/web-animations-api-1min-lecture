<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Starfield</title>
	<style>
		body {
			overflow: hidden;
			background-color: gold;
		}

		.star {
			position: absolute;
			width: 3px;
			height: 3px;
			/* font-size: 0; */
			border-radius: 50%;
			background: black;
		}

		.star:nth-child(20n) {
      width: 50px;
      height: 50px;
      background: url('./ilbuni-yoga.png') no-repeat 0 0 / cover
    }
	</style>
</head>
<body>
	<div class="starfield"></div>

  <!-- GroupEffect, SequanceEffect 사용 가능한 라이브러리 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/web-animations/2.3.2/web-animations-next.min.js"></script>
  <!--
    스타워즈 모듈 import 가능.
    모듈 사용 시 장점:
      - script영역에 직접 변수를 선언 시 글로벌 변수가 되는것에 비해,
      - 자체적으로 스코프가 생겨서 전역에서 접근이 안되는 점이 장점
  -->
	<script type="module">
    import Star from './Star.js';

    const numberOfStars = 200; // 별의 개수
    const canvasWidth = window.innerWidth;
    const canvasHeight = window.innerHeight;
    const zModifier = canvasHeight; // 위치값을 계속 변경해줄거기때문에 변수로 빼줌
    const effects = [];

    let x, y, z; // 별의 위치 결정
    let scale; // 별의 크기 결정
    let keyframes, options;
    let pointFrom, pointTo;
    let star;

    // 3차원 원근값 결정 : 별이 다가오면서 커지도록 위치에 따라 다시 결정되어야함
    function set3DPoint(x, y, z) {
      const scale = zModifier / (zModifier + z);

      // scale 자체가 z값에 따라 결정됨. 이 값에 맞게 x, y값도 변경하겠다는 것.
      const x2D = x * scale + window.innerWidth*0.5;
      const y2D = y * scale + window.innerWidth*0.5;

      return [x2D, y2D, scale]; // 3D가 아니라서 z값은 안넘겨줘도 됨
    }

    for (let i = 0; i < numberOfStars; i++) {
      // 가운데를 0으로 잡아서 ex)기존 0~1000에서 -500~500으로 변경
      x = (Math.random() * window.innerWidth - window.innerWidth*0.5); // 브라우저 너비 안에서 세팅되도록
      y = (Math.random() * window.innerHeight - window.innerHeight*0.5); // 브라우저 높이 안에서 세팅되도록
      z = (Math.random() * zModifier);

      scale = zModifier / (zModifier + z);

      pointFrom = set3DPoint(x, y, z);
      pointTo = set3DPoint(x, y, z - zModifier); // -값이 될수록 가까워지는거니까, zModifier만큼 가까워지도록

      star = new Star(i);

      keyframes = [
        {
          transform: `
            translate(${pointFrom[0]}px, ${pointFrom[1]}px)
            scale(${pointFrom[2]})
          `
        },
        {
          transform: `
            translate(${pointTo[0]}px, ${pointTo[1]}px)
            scale(${pointTo[2]})
          `
        }
      ]

      options = {
        // 한번에 촥 촥 펴졌다가 돌아가는 부자연스러움 해결을 위해 duration 제공
        // -> scale에 반비례하게 해줌.
        duration: 1000 / scale,
        iterations: Infinity,
        fill: 'both',
        easing: 'linear' // 가속 옵션 : 일정하게
      }

      effects.push(new KeyframeEffect(star.element, keyframes, options));
    }

    const groupEffect = new GroupEffect(effects);
    const animation = document.timeline.play(groupEffect);

    // 클릭 시 재생 여부 토글하는 기능 추가
    window.addEventListener('click', () => {
      if (animation.playState === 'running') {
        animation.pause();
      } else {
        animation.play();
      }
    })
	</script>
</body>
</html>
